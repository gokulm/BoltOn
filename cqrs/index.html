<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Cqrs - BoltOn</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cqrs";
    var mkdocs_page_input_path = "cqrs.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> BoltOn</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../requestor/">Requestor</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../data/">Data</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../bus/">Bus</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../cache/">Cache</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../hangfire/">Hangfire</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../statemachine/">State Machine</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../web/">Web</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../utilities/">Utilities</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../samples/">Samples</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../build/">CI & CD</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">BoltOn</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Cqrs</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>Command Query Responsibility Segregation (CQRS) pattern derives from the principle <a href="https://martinfowler.com/bliki/CommandQuerySeparation.html">Command Query Separation</a>, which states that:</p>
<blockquote>
<p>[E]very method should either be a command that performs an
action, or a query that returns data to the caller, but not both. In other
words, Asking a question should not change the answer.</p>

<p>– <cite><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Wikipedia</a></cite></p>
</blockquote>

<p>Command Query Responsibility Separation, or CQRS, takes this principle one step further.</p>
<blockquote>
<p>CQRS is simply the creation of two objects where there was previously only
one. The separation occurs based upon whether the methods are a command or
a query (the same definition that is used by Meyer in Command and Query
Separation: a command is any method that mutates state and a query is any
method that returns a value).</p>

<p>– <cite>Greg Young</cite></p>
</blockquote>

<p>To know more about the CQRS pattern and when to use it, please go over <a href="https://martinfowler.com/bliki/CQRS.html">this post</a>. </p>
<h2 id="implementation">Implementation</h2>
<p>Most of the CQRS implementations found over the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn covers it. <strong>However, the implementation here is just an idea and it doesn't cover all the possible usecases, so feel free to tweak the way you want it.</strong></p>
<p><strong>Data store synchronization could be handled by the following ways:</strong></p>
<ol>
<li>Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas.</li>
<li>By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using <a href="https://microservices.io/patterns/data/transactional-outbox.html">outbox pattern</a>.</li>
<li>Event sourcing - there are many libraries supporting event sourcing with CQRS.</li>
</ol>
<p>BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above, basically by doing something like this:</p>
<pre><code>public void PlaceOrder(Order order)
{
    BeginTransaction();
    Try 
    {
        SaveOrderToDataBase(order);
        ev = new OrderPlaced(Order);
        SaveEventToDataBase(ev);
        CommitTransaction();
    }
    Catch 
    {
        RollbackTransaction();
        return;
    }

    PublishEventAsync(ev);    
}

async Task PublishEventAsync(BussinesEvent ev) 
{
    BegintTransaction();
    try 
    {
        await DeleteEventAsync(ev);
        await bus.PublishAsync(ev);
        CommitTransaction();
    }
    catch 
    {
        RollbackTransaction();
    }
}
</code></pre>
<p><strong>Note:</strong> Code block copied from <a href="https://stackoverflow.com/questions/30780979/best-way-to-ensure-an-event-is-eventually-published-to-a-message-queuing-sytem">this StackOverflow answer</a>. </p>
<p>In BoltOn, business entity is persisted along with the events raised in the same data store and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a>. </p>
<p>In order to implement CQRS using BoltOn, you need to do the following:</p>
<ul>
<li>Install <strong>BoltOn.Data.EF</strong> NuGet package depending on your read/write data store (currently CQRS is supported only for SQL using EF).</li>
<li>Install <strong>BoltOn.Bus.MassTransit</strong> NuGet package. Refer to <a href="../data">Data</a> and <a href="../bus">Bus</a> documentation to enable the corresponding modules.</li>
<li>Configure EF DbContext (if you're using SQL) and MassTransit Bus.</li>
<li>Create your domain entity class by inheriting <a href="https://github.com/gokulm/BoltOn/blob/master/src/BoltOn/Cqrs/BaseDomainEntity.cs"><code>BaseDomainEntity</code></a> and override DomainEntityId property to return your Entity's Id property as string. </li>
<li>Create EF mapping configuration class by inheriting <a href="https://github.com/gokulm/BoltOn/blob/master/src/BoltOn.Data.EF/BaseDomainEntityMapping.cs"><code>BaseDomainEntityMapping</code></a>. This is mainly to ignore EventsToBeProcessed and PurgeEvents propery mappings. <em>Events that get triggered using <code>RaiseEvent&lt;TEvent&gt;(TEvent @event)</code> method in the <code>BaseDomainEntity</code> get added to EventsToBeProcessed collection and they get dispatched in the repository.</em></li>
<li>Create your events by implementing <code>IDomainEvent</code> or by inheriting <a href="https://github.com/gokulm/BoltOn/blob/master/src/BoltOn/Cqrs/BaseDomainEvent.cs"><code>BaseDomainEvent</code></a>. <em>It inturn implements Requestor's <code>IRequest</code>, and thus the events can be handled using <code>Requestor</code>.</em></li>
<li>Create your request and handlers, and then use the <code>Requestor</code> to process your request. Please refer to <a href="../requestor">Requestor</a> documentation to create handlers.</li>
<li>Register <code>IRepository&lt;TEntity&gt;</code> to EF <a href="https://github.com/gokulm/BoltOn/blob/master/src/BoltOn.Data.EF/CqrsRepository.cs"><code>CqrsRepository</code></a>.</li>
<li>
<p>Create a table for EventStore. Here is the script:</p>
<pre><code>CREATE TABLE [dbo].[EventStore](
[EventId] [uniqueidentifier] NOT NULL,
[Data] [nvarchar](max) NULL,
[EntityType] [nvarchar](max) NULL,
[EntityId] [nvarchar](max) NULL,
[CreatedDate] [datetimeoffset](7) NULL,
[ProcessedDate] [datetimeoffset](7) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
ALTER TABLE [dbo].[EventStore] ADD  CONSTRAINT [PK_EventStore] PRIMARY KEY CLUSTERED 
(
    [EventId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
</code></pre>
</li>
<li>
<p>Create EF mapping for <a href="https://github.com/gokulm/BoltOn/blob/master/src/BoltOn/Cqrs/EventStore.cs"><code>EventStore</code></a>, add the mapping to your DbContext and register <code>IRepository&lt;EventStore&gt;</code>.</p>
</li>
</ul>
<p>All the registration:</p>
<pre><code>public void ConfigureServices(IServiceCollection services)
{
    services.AddDefaultCorrelationId();
    services.BoltOn(options =&gt;
    {
        options.BoltOnEFModule();
        options.BoltOnMassTransitBusModule();
    });

    var boltOnSamplesDbConnectionString = Configuration.GetValue&lt;string&gt;("BoltOnSamplesDbConnectionString");

    services.AddDbContext&lt;SchoolDbContext&gt;(options =&gt;
    {
        options.UseSqlServer(boltOnSamplesDbConnectionString);
    });

    var rabbitmqUri = Configuration.GetValue&lt;string&gt;("RabbitMqUri");
    var rabbitmqUsername = Configuration.GetValue&lt;string&gt;("RabbitMqUsername");
    var rabbitmqPassword = Configuration.GetValue&lt;string&gt;("RabbitMqPassword");
    var redisUrl = Configuration.GetValue&lt;string&gt;("RedisUrl");
    services.AddMassTransit(x =&gt;
    {
        x.AddBus(provider =&gt; MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg =&gt;
        {
            cfg.Host(new Uri(rabbitmqUri), hostConfigurator =&gt;
            {
                hostConfigurator.Username(rabbitmqUsername);
                hostConfigurator.Password(rabbitmqPassword);
            });
        }));
    });

    services.AddTransient&lt;IRepository&lt;EventStore&gt;, Repository&lt;EventStore, SchoolDbContext&gt;&gt;();
    services.AddTransient&lt;IRepository&lt;Student&gt;, Repository&lt;Student, SchoolDbContext&gt;&gt;();
    services.AddTransient&lt;IRepository&lt;StudentFlattened&gt;, Repository&lt;StudentFlattened, SchoolDbContext&gt;&gt;();
    services.AddTransient&lt;IQueryRepository&lt;StudentType&gt;, QueryRepository&lt;StudentType, SchoolDbContext&gt;&gt;();
    services.AddTransient&lt;IQueryRepository&lt;Course&gt;, QueryRepository&lt;Course, SchoolDbContext&gt;&gt;();
}
</code></pre>
<h2 id="how-does-it-work">How does it work?</h2>
<p>The best way to understand the implementation is by looking into <a href="https://github.com/gokulm/BoltOn/tree/master/samples/BoltOn.Samples.WebApi">BoltOn.Samples.WebApi</a> project's <code>StudentsController</code> and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. </p>
<p>In this sample we have used only two tables - Student and StudentFlattened.</p>
<ul>
<li>The events that get raised from your entities (that inherit BaseDomainEntity) get added to EventsToBeProcessed collection. There are two entities - <a href="https://github.com/gokulm/BoltOn/blob/master/samples/BoltOn.Samples.Application/Entities/Student.cs"><code>Student</code></a> and <a href="https://github.com/gokulm/BoltOn/blob/master/samples/BoltOn.Samples.Application/Entities/StudentFlattened.cs"><code>StudentFlattened</code></a>. Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints, and queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter.</li>
<li>Student's internal ctor is called from <code>CreateStudentHandler</code>, which gets invoked by <code>Requestor</code> from StudentController's POST call.</li>
<li><code>StudentCreatedEvent</code> event inherits <code>BaseDomainEvent</code>. Other properties that are required to create StudentFlattened entity are added. It is triggered in the ctor by calling the base class' <code>RaiseEvent</code> method. </li>
</ul>
<p><strong>Note:</strong> </p>
<ul>
<li>The RaiseEvent method takes care of populating EventId if it's not already populated. </li>
<li>The triggered events get added to EventsToBeProcessed collection only if they're not already present. </li>
</ul>
<p>Here is the Student entity:</p>
<pre><code>public class Student : BaseDomainEntity
{
    private List&lt;StudentCourse&gt; _courses = new List&lt;StudentCourse&gt;();

    public virtual Guid StudentId { get; private set; }
    public virtual string FirstName { get; private set; }
    public virtual string LastName { get; private set; }
    public virtual string Email { get; private set; }
    public virtual int StudentTypeId { get; private set; }

    public override bool PurgeEvents { get; set; } = false;

    public override string DomainEntityId =&gt; StudentId.ToString();

    private Student()
    {
    }

    internal Student(CreateStudentRequest request, string studentType)
    {
        StudentId = Guid.NewGuid();
        FirstName = request.FirstName;
        LastName = request.LastName;
        StudentTypeId = request.StudentTypeId;
        Email = request.Email;

        RaiseEvent(new StudentCreatedEvent(StudentId, FirstName, LastName,
            Email, StudentTypeId, studentType));
    }
}
</code></pre>
<ul>
<li><code>IRepository&lt;Student&gt;</code> injected in the <code>CreateStudentHandler</code> is registered to use <code>CqrsRepository&lt;Student&gt;</code>. Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations.</li>
<li>When <code>AddAsync</code> of the repository is called in the handler, the repository adds the entity and while saving changes, the events get added to EventStore table along with Student entity in the same transaction, and in a separate transaction the events get published to the bus.</li>
<li>The <em>PurgeEvents</em> property in <code>BaseDomainEntity</code> is set to true by default, which controls whether the events in <code>EventStore</code> should be deleted or not after publishing the events. </li>
<li>If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained.</li>
<li>The MassTransit consumer registered to handle <code>StudentCreatedEvent</code> in the BoltOn.Samples.Console project's Startup class handles the event using <code>StudentCreatedEventHandler</code>.</li>
</ul>
<p>Here is the registration:</p>
<pre><code>container.AddMassTransit(x =&gt;
{
    x.AddBus(provider =&gt; MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg =&gt;
    {
        var host = cfg.Host(new Uri("rabbitmq://localhost:5672"), hostConfigurator =&gt;
        {
            hostConfigurator.Username("guest");
            hostConfigurator.Password("guest");
        });

        cfg.ReceiveEndpoint("StudentCreatedEvent_queue", ep =&gt;
        {
            ep.Consumer(() =&gt; provider.GetService&lt;BoltOnMassTransitConsumer&lt;StudentCreatedEvent&gt;&gt;());
        });
    }));
});
</code></pre>
<ul>
<li>StudentFlattened's internal ctor is called from <code>StudentCreatedHandler</code>, which gets invoked by <code>Requestor</code> from <code>BoltOnMassTransitConsumer&lt;StudentCreatedEvent&gt;</code></li>
</ul>
<p>Here is the StudentFlattened entity:</p>
<pre><code>public class StudentFlattened 
{
    public Guid StudentId { get; set; }
    public string FirstName { get; private set; }
    public string LastName { get; private set; }
    public string StudentType { get; private set; }
    public int StudentTypeId { get; private set; }

    private StudentFlattened()
    {
    }

    internal StudentFlattened(StudentCreatedEvent @event)
    {
        StudentId = @event.StudentId;
        FirstName = @event.FirstName;
        LastName = @event.LastName;
        StudentType = @event.StudentType;
        StudentTypeId = @event.StudentTypeId;
    }
}
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>There are chances for the events to be published more than once, especially when there are concurrent requests, so it's better to develop the event consumers in such a way that they're idempotent, by basically maintaining all the processes events (or just the processed eventids) in a separate table or by not purging events in the EventStore table and relying on the ProcessedDate column.</li>
</ul>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
