{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BoltOn is an open source application framework to help develop simple/modular/extensible/unit-testable .NET applications (Console, MVC, WebAPI, Windows Service etc.,) with reduced boilerplate code. The components are written in such a way that they're modular , thus they can be plugged with other components and interchanged easily, and hence the name Bolt-On. Installation To install BoltOn in your .NET application, type the following command in the Package Manager Console window: PM> Install-Package BoltOn From CLI: dotnet add package BoltOn Or, can be added from VS NuGet Package Manager. Here is the list of NuGet Packages . Configuration After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifeTime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); lifetime.ApplicationStopping.Register( () => app.ApplicationServices.LoosenBolts()); } } } To use other BoltOn packages and/or add other assemblies, add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call. BoltOn() This method does the following: Registers all the interfaces in the calling assembly and assemblies passed to BoltOnAssemblies() method with single implementation as trasient. Registers all the Requestor handlers. Note: The order of the methods called is important. If BoltOnEFModule() is called after BoltOnAssemblies(), the assemblies passed to the latter will override the registrations. To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. Use the BootstrapperOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules. TightenBolts() This extension method scans all the implementations of IPostRegistrationTask interface in the assemblies passed to BoltOnAssemblies() and executes them. The post registration tasks support constructor injection. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { private readonly SchoolDbContext _schoolDbContext; public CustomPostRegistrationTask(SchoolDbContext schoolDbContext) { _schoolDbContext = schoolDbContext; } public void Run() { _schoolDbContext.Database.EnsureCreated(); _schoolDbContext.Set<Student>().Add(new Student { Id = 1, FirstName = \"a\", LastName = \"b\" }); _schoolDbContext.SaveChanges(); _schoolDbContext.Dispose(); } } LoosenBolts() This extension method scans all the implementations of ICleanupTask interface in the assemblies passed to BoltOnAssemblies() and executes them. This is mainly used to dispose and perform other clean-up tasks. Example: public class CleanupTask : ICleanupTask { private readonly IServiceProvider _serviceProvider; public CleanupTask(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void Run() { var busControl = _serviceProvider.GetService<IBusControl>(); busControl?.Stop(); } }","title":"Introduction"},{"location":"#installation","text":"To install BoltOn in your .NET application, type the following command in the Package Manager Console window: PM> Install-Package BoltOn From CLI: dotnet add package BoltOn Or, can be added from VS NuGet Package Manager. Here is the list of NuGet Packages .","title":"Installation"},{"location":"#configuration","text":"After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifeTime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); lifetime.ApplicationStopping.Register( () => app.ApplicationServices.LoosenBolts()); } } } To use other BoltOn packages and/or add other assemblies, add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call.","title":"Configuration"},{"location":"#bolton","text":"This method does the following: Registers all the interfaces in the calling assembly and assemblies passed to BoltOnAssemblies() method with single implementation as trasient. Registers all the Requestor handlers. Note: The order of the methods called is important. If BoltOnEFModule() is called after BoltOnAssemblies(), the assemblies passed to the latter will override the registrations. To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. Use the BootstrapperOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules.","title":"BoltOn()"},{"location":"#tightenbolts","text":"This extension method scans all the implementations of IPostRegistrationTask interface in the assemblies passed to BoltOnAssemblies() and executes them. The post registration tasks support constructor injection. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { private readonly SchoolDbContext _schoolDbContext; public CustomPostRegistrationTask(SchoolDbContext schoolDbContext) { _schoolDbContext = schoolDbContext; } public void Run() { _schoolDbContext.Database.EnsureCreated(); _schoolDbContext.Set<Student>().Add(new Student { Id = 1, FirstName = \"a\", LastName = \"b\" }); _schoolDbContext.SaveChanges(); _schoolDbContext.Dispose(); } }","title":"TightenBolts()"},{"location":"#loosenbolts","text":"This extension method scans all the implementations of ICleanupTask interface in the assemblies passed to BoltOnAssemblies() and executes them. This is mainly used to dispose and perform other clean-up tasks. Example: public class CleanupTask : ICleanupTask { private readonly IServiceProvider _serviceProvider; public CleanupTask(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void Run() { var busControl = _serviceProvider.GetService<IBusControl>(); busControl?.Stop(); } }","title":"LoosenBolts()"},{"location":"build/","text":"BoltOn uses GitHub Actions for CI and CD. CI involves just building and testing the projects, whereas CD involves building, testing, versioning, packing and publishing to NuGet, and tagging. Though pretty much most of them could be achieved using the GitHub tasks, we are using PowerShell to mainly support performing all the tasks locally. Both the PS scripts ( build.ps1 and publish.ps1 ) use some of the functions in bolton.psm1 . Versioning is done based on Conventional Commits . Here it is: feat: Increments minor version fix: Increments patch version feat! and fix!: Increments major version publish.ps1 script finds all the changed projects in a merge, and increments the version(s) of them based on the commit message. To force changing the versions of projects without making any changes to the project files, scope could be specified in the commit message: Example: feat(BoltOn, BoltOn.Data.EF): test comments Which will increment minor versions of both BoltOn and BoltOn.Data.EF projects, and publish them.","title":"CI & CD"},{"location":"bus/","text":"BoltOn uses MassTransit bus for all the queueing. In order to use the bus, do the following: Install BoltOn.Bus.MassTransit NuGet package. Call BoltOnMassTransitModule() in your startup's BoltOn() method. For all the applications that will be just publishing to the queue, configure RabbitMq host and all other settings using MassTransit's extension method for AddMassTransit . Check out this page for the supported configuration. Also refer MassTransit's documentation for all the other supported transports (other than RabbitMq), BoltOnMassTransitModule is transport agnostic. For all the applications that will be consuming messages from the queue, follow all the above steps and then configure BoltOn's AppMessageConsumer<TMessage> provided by the above mentioned NuGet package. Finally, inject IAppServiceBus in your application and call PublishAsync method to publish your message. Example: Publisher Configuration services.BoltOn(options => { options.BoltOnMassTransitBusModule(); }); services.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); })); }); Consumer Configuration serviceCollection.AddMassTransit(x => { x.AddConsumer<AppMessageConsumer<StudentCreatedEvent>>() .Endpoint(e => { e.Name = $\"{nameof(StudentCreatedEvent)}_queue\"; }); x.UsingRabbitMq((context, cfg) => { cfg.Host(new Uri(rabbitmqUri), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint($\"{nameof(StudentCreatedEvent)}_queue\", e => { e.ConfigureConsumer<AppMessageConsumer<StudentCreatedEvent>>(context); }); }); }); Note: As MassTransit had abstracted out the transport like RabbitMq, Azure Service Bus etc., and all the other things very well, BoltOn just adds a minor add-on AppMessageConsumer<TMessage> to it, which injects IRequestor for processing TMessage of type IRequest . As the consumer injects IRequestor and uses it for processing the messages, please refer to Requestor documentation to know how to add handlers and its internals. Starting and stopping bus gets taken care by PostRegistrationTask and CleanupTask respectively.","title":"Bus"},{"location":"cache/","text":"BoltOn Cache is just an adapter for .NET Core's IDistributedCache . In order to use it, you have to do the following: Install BoltOn.Cache NuGet package in the host project. Call BoltOnCacheModule() in your startup's BoltOn() method. Install the appropriate NuGet package depending on the IDistributedCache implementations that .NET Core provides - Memory, Redis and SQL Server. Use the appropriate extension methods like AddDistributedMemoryCache or AddDistributedSqlServerCache or AddStackExchangeRedisCache to configure the underlying cache. Finally, inject IAppCache whereever you want in your application. Example: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnCacheModule(); }); To use Redis, install Microsoft.Extensions.Caching.StackExchangeRedis and then add serviceCollection.AddStackExchangeRedisCache(options => { options.Configuration = \"localhost:6379\"; }); To use in-memory cache: services.AddDistributedMemoryCache(); Note: AppCache uses .NET Core's built-in serializer (System.Text.Json) for serializing cache values to byte array. You can switch the serializer by writing your own implementation for IAppCacheSerializer and registering the implementation while bootstrapping your application. Check out .NET Core's IDistributedCache documentation to know more about the other configurations and usage.","title":"Cache"},{"location":"cli/","text":"In order to create project templates and other BoltOn components from CLI, execute: dotnet new -i BoltOn.Templates WebAPI To create a .NET Core WebAPI project with BoltOn package added: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name Handler To create a Requestor handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } } Handler (with response) To create a Requestor handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Cli"},{"location":"cli/#webapi","text":"To create a .NET Core WebAPI project with BoltOn package added: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name","title":"WebAPI"},{"location":"cli/#handler","text":"To create a Requestor handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler"},{"location":"cli/#handler-with-response","text":"To create a Requestor handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler (with response)"},{"location":"cqrs/","text":"Command Query Responsibility Segregation (CQRS) pattern derives from the principle Command Query Separation , which states that: [E]very method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, Asking a question should not change the answer. \u2013 Wikipedia Command Query Responsibility Separation, or CQRS, takes this principle one step further. CQRS is simply the creation of two objects where there was previously only one. The separation occurs based upon whether the methods are a command or a query (the same definition that is used by Meyer in Command and Query Separation: a command is any method that mutates state and a query is any method that returns a value). \u2013 Greg Young To know more about the CQRS pattern and when to use it, please go over this post . Implementation Most of the CQRS implementations found over the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn covers it. However, the implementation here is just an idea and it doesn't cover all the possible usecases, so feel free to tweak the way you want it. Data store synchronization could be handled by the following ways: Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas. By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using outbox pattern . Event sourcing - there are many libraries supporting event sourcing with CQRS. BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above, basically by doing something like this: public void PlaceOrder(Order order) { BeginTransaction(); Try { SaveOrderToDataBase(order); ev = new OrderPlaced(Order); SaveEventToDataBase(ev); CommitTransaction(); } Catch { RollbackTransaction(); return; } PublishEventAsync(ev); } async Task PublishEventAsync(BussinesEvent ev) { BegintTransaction(); try { await DeleteEventAsync(ev); await bus.PublishAsync(ev); CommitTransaction(); } catch { RollbackTransaction(); } } Note: Code block copied from this StackOverflow answer . In BoltOn, business entity is persisted along with the events raised in the same data store and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with eventual consistency . In order to implement CQRS using BoltOn, you need to do the following: Install BoltOn.Data.EF NuGet package depending on your read/write data store (currently CQRS is supported only for SQL using EF). Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Configure EF DbContext (if you're using SQL) and MassTransit Bus. Create your domain entity class by inheriting BaseDomainEntity and override DomainEntityId property to return your Entity's Id property as string. Create EF mapping configuration class by inheriting BaseDomainEntityMapping . This is mainly to ignore EventsToBeProcessed and PurgeEvents propery mappings. Events that get triggered using RaiseEvent<TEvent>(TEvent @event) method in the BaseDomainEntity get added to EventsToBeProcessed collection and they get dispatched in the repository. Create your events by implementing IDomainEvent or by inheriting BaseDomainEvent . It inturn implements Requestor's IRequest , and thus the events can be handled using Requestor . Create your request and handlers, and then use the Requestor to process your request. Please refer to Requestor documentation to create handlers. Register IRepository<TEntity> to EF CqrsRepository . Create a table for EventStore. Here is the script: CREATE TABLE [dbo].[EventStore]( [EventId] [uniqueidentifier] NOT NULL, [Data] [nvarchar](max) NULL, [EntityType] [nvarchar](max) NULL, [EntityId] [nvarchar](max) NULL, [CreatedDate] [datetimeoffset](7) NULL, [ProcessedDate] [datetimeoffset](7) NULL ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO ALTER TABLE [dbo].[EventStore] ADD CONSTRAINT [PK_EventStore] PRIMARY KEY CLUSTERED ( [EventId] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO Create EF mapping for EventStore , add the mapping to your DbContext and register IRepository<EventStore> . All the registration: public void ConfigureServices(IServiceCollection services) { services.AddDefaultCorrelationId(); services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnMassTransitBusModule(); }); var boltOnSamplesDbConnectionString = Configuration.GetValue<string>(\"BoltOnSamplesDbConnectionString\"); services.AddDbContext<SchoolDbContext>(options => { options.UseSqlServer(boltOnSamplesDbConnectionString); }); var rabbitmqUri = Configuration.GetValue<string>(\"RabbitMqUri\"); var rabbitmqUsername = Configuration.GetValue<string>(\"RabbitMqUsername\"); var rabbitmqPassword = Configuration.GetValue<string>(\"RabbitMqPassword\"); var redisUrl = Configuration.GetValue<string>(\"RedisUrl\"); services.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { cfg.Host(new Uri(rabbitmqUri), hostConfigurator => { hostConfigurator.Username(rabbitmqUsername); hostConfigurator.Password(rabbitmqPassword); }); })); }); services.AddTransient<IRepository<EventStore>, Repository<EventStore, SchoolDbContext>>(); services.AddTransient<IRepository<Student>, Repository<Student, SchoolDbContext>>(); services.AddTransient<IRepository<StudentFlattened>, Repository<StudentFlattened, SchoolDbContext>>(); services.AddTransient<IQueryRepository<StudentType>, QueryRepository<StudentType, SchoolDbContext>>(); services.AddTransient<IQueryRepository<Course>, QueryRepository<Course, SchoolDbContext>>(); } How does it work? The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. In this sample we have used only two tables - Student and StudentFlattened. The events that get raised from your entities (that inherit BaseDomainEntity) get added to EventsToBeProcessed collection. There are two entities - Student and StudentFlattened . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints, and queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Requestor from StudentController's POST call. StudentCreatedEvent event inherits BaseDomainEvent . Other properties that are required to create StudentFlattened entity are added. It is triggered in the ctor by calling the base class' RaiseEvent method. Note: The RaiseEvent method takes care of populating EventId if it's not already populated. The triggered events get added to EventsToBeProcessed collection only if they're not already present. Here is the Student entity: public class Student : BaseDomainEntity { private List<StudentCourse> _courses = new List<StudentCourse>(); public virtual Guid StudentId { get; private set; } public virtual string FirstName { get; private set; } public virtual string LastName { get; private set; } public virtual string Email { get; private set; } public virtual int StudentTypeId { get; private set; } public override bool PurgeEvents { get; set; } = false; public override string DomainEntityId => StudentId.ToString(); private Student() { } internal Student(CreateStudentRequest request, string studentType) { StudentId = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; Email = request.Email; RaiseEvent(new StudentCreatedEvent(StudentId, FirstName, LastName, Email, StudentTypeId, studentType)); } } IRepository<Student> injected in the CreateStudentHandler is registered to use CqrsRepository<Student> . Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and while saving changes, the events get added to EventStore table along with Student entity in the same transaction, and in a separate transaction the events get published to the bus. The PurgeEvents property in BaseDomainEntity is set to true by default, which controls whether the events in EventStore should be deleted or not after publishing the events. If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained. The MassTransit consumer registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's Startup class handles the event using StudentCreatedEventHandler . Here is the registration: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Requestor from BoltOnMassTransitConsumer<StudentCreatedEvent> Here is the StudentFlattened entity: public class StudentFlattened { public Guid StudentId { get; set; } public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } public int StudentTypeId { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { StudentId = @event.StudentId; FirstName = @event.FirstName; LastName = @event.LastName; StudentType = @event.StudentType; StudentTypeId = @event.StudentTypeId; } } Note: There are chances for the events to be published more than once, especially when there are concurrent requests, so it's better to develop the event consumers in such a way that they're idempotent, by basically maintaining all the processes events (or just the processed eventids) in a separate table or by not purging events in the EventStore table and relying on the ProcessedDate column.","title":"Cqrs"},{"location":"cqrs/#implementation","text":"Most of the CQRS implementations found over the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn covers it. However, the implementation here is just an idea and it doesn't cover all the possible usecases, so feel free to tweak the way you want it. Data store synchronization could be handled by the following ways: Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas. By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using outbox pattern . Event sourcing - there are many libraries supporting event sourcing with CQRS. BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above, basically by doing something like this: public void PlaceOrder(Order order) { BeginTransaction(); Try { SaveOrderToDataBase(order); ev = new OrderPlaced(Order); SaveEventToDataBase(ev); CommitTransaction(); } Catch { RollbackTransaction(); return; } PublishEventAsync(ev); } async Task PublishEventAsync(BussinesEvent ev) { BegintTransaction(); try { await DeleteEventAsync(ev); await bus.PublishAsync(ev); CommitTransaction(); } catch { RollbackTransaction(); } } Note: Code block copied from this StackOverflow answer . In BoltOn, business entity is persisted along with the events raised in the same data store and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with eventual consistency . In order to implement CQRS using BoltOn, you need to do the following: Install BoltOn.Data.EF NuGet package depending on your read/write data store (currently CQRS is supported only for SQL using EF). Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Configure EF DbContext (if you're using SQL) and MassTransit Bus. Create your domain entity class by inheriting BaseDomainEntity and override DomainEntityId property to return your Entity's Id property as string. Create EF mapping configuration class by inheriting BaseDomainEntityMapping . This is mainly to ignore EventsToBeProcessed and PurgeEvents propery mappings. Events that get triggered using RaiseEvent<TEvent>(TEvent @event) method in the BaseDomainEntity get added to EventsToBeProcessed collection and they get dispatched in the repository. Create your events by implementing IDomainEvent or by inheriting BaseDomainEvent . It inturn implements Requestor's IRequest , and thus the events can be handled using Requestor . Create your request and handlers, and then use the Requestor to process your request. Please refer to Requestor documentation to create handlers. Register IRepository<TEntity> to EF CqrsRepository . Create a table for EventStore. Here is the script: CREATE TABLE [dbo].[EventStore]( [EventId] [uniqueidentifier] NOT NULL, [Data] [nvarchar](max) NULL, [EntityType] [nvarchar](max) NULL, [EntityId] [nvarchar](max) NULL, [CreatedDate] [datetimeoffset](7) NULL, [ProcessedDate] [datetimeoffset](7) NULL ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO ALTER TABLE [dbo].[EventStore] ADD CONSTRAINT [PK_EventStore] PRIMARY KEY CLUSTERED ( [EventId] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO Create EF mapping for EventStore , add the mapping to your DbContext and register IRepository<EventStore> . All the registration: public void ConfigureServices(IServiceCollection services) { services.AddDefaultCorrelationId(); services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnMassTransitBusModule(); }); var boltOnSamplesDbConnectionString = Configuration.GetValue<string>(\"BoltOnSamplesDbConnectionString\"); services.AddDbContext<SchoolDbContext>(options => { options.UseSqlServer(boltOnSamplesDbConnectionString); }); var rabbitmqUri = Configuration.GetValue<string>(\"RabbitMqUri\"); var rabbitmqUsername = Configuration.GetValue<string>(\"RabbitMqUsername\"); var rabbitmqPassword = Configuration.GetValue<string>(\"RabbitMqPassword\"); var redisUrl = Configuration.GetValue<string>(\"RedisUrl\"); services.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { cfg.Host(new Uri(rabbitmqUri), hostConfigurator => { hostConfigurator.Username(rabbitmqUsername); hostConfigurator.Password(rabbitmqPassword); }); })); }); services.AddTransient<IRepository<EventStore>, Repository<EventStore, SchoolDbContext>>(); services.AddTransient<IRepository<Student>, Repository<Student, SchoolDbContext>>(); services.AddTransient<IRepository<StudentFlattened>, Repository<StudentFlattened, SchoolDbContext>>(); services.AddTransient<IQueryRepository<StudentType>, QueryRepository<StudentType, SchoolDbContext>>(); services.AddTransient<IQueryRepository<Course>, QueryRepository<Course, SchoolDbContext>>(); }","title":"Implementation"},{"location":"cqrs/#how-does-it-work","text":"The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. In this sample we have used only two tables - Student and StudentFlattened. The events that get raised from your entities (that inherit BaseDomainEntity) get added to EventsToBeProcessed collection. There are two entities - Student and StudentFlattened . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints, and queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Requestor from StudentController's POST call. StudentCreatedEvent event inherits BaseDomainEvent . Other properties that are required to create StudentFlattened entity are added. It is triggered in the ctor by calling the base class' RaiseEvent method. Note: The RaiseEvent method takes care of populating EventId if it's not already populated. The triggered events get added to EventsToBeProcessed collection only if they're not already present. Here is the Student entity: public class Student : BaseDomainEntity { private List<StudentCourse> _courses = new List<StudentCourse>(); public virtual Guid StudentId { get; private set; } public virtual string FirstName { get; private set; } public virtual string LastName { get; private set; } public virtual string Email { get; private set; } public virtual int StudentTypeId { get; private set; } public override bool PurgeEvents { get; set; } = false; public override string DomainEntityId => StudentId.ToString(); private Student() { } internal Student(CreateStudentRequest request, string studentType) { StudentId = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; Email = request.Email; RaiseEvent(new StudentCreatedEvent(StudentId, FirstName, LastName, Email, StudentTypeId, studentType)); } } IRepository<Student> injected in the CreateStudentHandler is registered to use CqrsRepository<Student> . Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and while saving changes, the events get added to EventStore table along with Student entity in the same transaction, and in a separate transaction the events get published to the bus. The PurgeEvents property in BaseDomainEntity is set to true by default, which controls whether the events in EventStore should be deleted or not after publishing the events. If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained. The MassTransit consumer registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's Startup class handles the event using StudentCreatedEventHandler . Here is the registration: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Requestor from BoltOnMassTransitConsumer<StudentCreatedEvent> Here is the StudentFlattened entity: public class StudentFlattened { public Guid StudentId { get; set; } public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } public int StudentTypeId { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { StudentId = @event.StudentId; FirstName = @event.FirstName; LastName = @event.LastName; StudentType = @event.StudentType; StudentTypeId = @event.StudentTypeId; } } Note: There are chances for the events to be published more than once, especially when there are concurrent requests, so it's better to develop the event consumers in such a way that they're idempotent, by basically maintaining all the processes events (or just the processed eventids) in a separate table or by not purging events in the EventStore table and relying on the ProcessedDate column.","title":"How does it work?"},{"location":"data/","text":"Repository IRepository and IQueryRepository interfaces in the core BoltOn package is abstracted out to keep it agnostic of any particular database. However, they're currently implemented only in BoltOn.Data.EF package. There are separate IRepository interfaces in CosmosDb and ElasticSearch packages too. Entity Framework Repository In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Register IRepository<TEntity> to Repository<TEntity, TDbContext> or IQueryRepository<TEntity> to QueryRepository<TEntity, TDbContext> . IQueryRepository has only methods related to data retrieval, and it sets EF's QueryTrackingBehavior to QueryTrackingBehavior.NoTracking . Example: services.BoltOn(options => { options.BoltOnEFModule(); }); services.AddDbContext<SchoolDbContext>(options => { options.UseSqlServer(\"connectionstring\"); }); services.AddTransient<IRepository<Student>, Repository<Student, SchoolDbContext>>(); services.AddTransient<IQueryRepository<Course>, QueryRepository<Student, SchoolDbContext>>(); The database table mappings can be added within your DbContext or in a separate class by implementing IEntityTypeConfiguration<TEntity> interface. Example: // DbContext public class SchoolDbContext : DbContext { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student { public int StudentId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.StudentId); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } You can override the Repository class' methods or add methods by inheriting Repository or QueryRepository . Example: // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(SchoolDbContext schoolDbContext) : base(schoolDbContext) { } } Note: Entity Framework has an extension method ApplyConfigurationsFromAssembly to add all the configurations in an assembly; in case if you want to add configurations only from certain namespace in an assembly, the extension method ApplyConfigurationsFromNamespaceOfType<T> , which is part of BoltOn.Data.EF can be used. Like this: protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.ApplyConfigurationsFromNamespaceOfType<StudentMapping>(); } Elasticsearch BoltOn.Data.Elasticsearch uses NEST library internally. In order to use Elasticsearch, you need do the following: Install BoltOn.Data.Elasticsearch NuGet package. Call BoltOnElasticsearchModule() in your startup's BoltOn() method. Create an options class by inheriting BaseElasticsearchOptions class. Use AddElasticsearch extension method to initialize NEST library's ConnectionSettings. Inherit Repository<TEntity, TElasticsearchOptions> to create a repository for your entity. Here is the implementation Repository<TEntity, TElasticsearchOptions> . Example: services.BoltOn(options => { options.BoltOnElasticsearchModule(); }); services.AddElasticsearch<SchoolElasticDbOptions>(options => { options.ConnectionSettings = new Nest.ConnectionSettings(new Uri(\"http://127.0.0.1:9200\")); }); public class SchoolElasticDbOptions : BaseElasticsearchOptions { } // Entity public class Student { public int StudentId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolElasticDbOptions>>() Example: var searchRequest = new SearchRequest { Query = new MatchQuery { Field = \"firstName\", Query = \"John\" } }; repository.FindByAsync(searchRequest)","title":"Data"},{"location":"data/#repository","text":"IRepository and IQueryRepository interfaces in the core BoltOn package is abstracted out to keep it agnostic of any particular database. However, they're currently implemented only in BoltOn.Data.EF package. There are separate IRepository interfaces in CosmosDb and ElasticSearch packages too.","title":"Repository"},{"location":"data/#entity-framework-repository","text":"In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Register IRepository<TEntity> to Repository<TEntity, TDbContext> or IQueryRepository<TEntity> to QueryRepository<TEntity, TDbContext> . IQueryRepository has only methods related to data retrieval, and it sets EF's QueryTrackingBehavior to QueryTrackingBehavior.NoTracking . Example: services.BoltOn(options => { options.BoltOnEFModule(); }); services.AddDbContext<SchoolDbContext>(options => { options.UseSqlServer(\"connectionstring\"); }); services.AddTransient<IRepository<Student>, Repository<Student, SchoolDbContext>>(); services.AddTransient<IQueryRepository<Course>, QueryRepository<Student, SchoolDbContext>>(); The database table mappings can be added within your DbContext or in a separate class by implementing IEntityTypeConfiguration<TEntity> interface. Example: // DbContext public class SchoolDbContext : DbContext { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student { public int StudentId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.StudentId); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } You can override the Repository class' methods or add methods by inheriting Repository or QueryRepository . Example: // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(SchoolDbContext schoolDbContext) : base(schoolDbContext) { } } Note: Entity Framework has an extension method ApplyConfigurationsFromAssembly to add all the configurations in an assembly; in case if you want to add configurations only from certain namespace in an assembly, the extension method ApplyConfigurationsFromNamespaceOfType<T> , which is part of BoltOn.Data.EF can be used. Like this: protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.ApplyConfigurationsFromNamespaceOfType<StudentMapping>(); }","title":"Entity Framework Repository"},{"location":"data/#elasticsearch","text":"BoltOn.Data.Elasticsearch uses NEST library internally. In order to use Elasticsearch, you need do the following: Install BoltOn.Data.Elasticsearch NuGet package. Call BoltOnElasticsearchModule() in your startup's BoltOn() method. Create an options class by inheriting BaseElasticsearchOptions class. Use AddElasticsearch extension method to initialize NEST library's ConnectionSettings. Inherit Repository<TEntity, TElasticsearchOptions> to create a repository for your entity. Here is the implementation Repository<TEntity, TElasticsearchOptions> . Example: services.BoltOn(options => { options.BoltOnElasticsearchModule(); }); services.AddElasticsearch<SchoolElasticDbOptions>(options => { options.ConnectionSettings = new Nest.ConnectionSettings(new Uri(\"http://127.0.0.1:9200\")); }); public class SchoolElasticDbOptions : BaseElasticsearchOptions { } // Entity public class Student { public int StudentId { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolElasticDbOptions>>() Example: var searchRequest = new SearchRequest { Query = new MatchQuery { Field = \"firstName\", Query = \"John\" } }; repository.FindByAsync(searchRequest)","title":"Elasticsearch"},{"location":"hangfire/","text":"Hangfire can be used along with BoltOn for all the background and scheduled jobs. In order to use it, do the following: Install BoltOn.Hangfire NuGet package. Call BoltOnHangfireModule() in your startup's BoltOn() method. Configure Hangfire by referring to its documentation. Once all the configuration is done, create a request (without response) class that implements IRequest and a handler that implements IHandler<in TRequest> . Refer to Requestor to know more about the implementation. Finally, use AppHangfireJobProcessor to configure the request/handler as a background or scheduled job. Example: While bootstrapping your application serviceCollection.BoltOn(o => { o.BoltOnHangfireModule(); }); // hangfire configuration GlobalConfiguration.Configuration .UseSqlServerStorage(\"connectionstring to the db\"); // a job to be executed every minute RecurringJob.AddOrUpdate<AppHangfireJobProcessor>(\"StudentsNotifier\", p => p.ProcessAsync(new NotifyStudentsRequest { JobType = \"Recurring\" }, default), Cron.Minutely()); // to schededule an one-time background job BackgroundJob.Schedule<AppHangfireJobProcessor>(p => p.ProcessAsync(new NotifyStudentsRequest { JobType = \"OneTime\" }, default), TimeSpan.FromSeconds(30)); Request and Handler public class NotifyStudentsRequest : IRequest { public string JobType { get; set; } public override string ToString() { return \"Student Notifier \" + JobType; } } public class NotifyStudentsHandler : IHandler<NotifyStudentsRequest> { private readonly IAppLogger<NotifyStudentsHandler> _logger; public NotifyStudentsHandler(IAppLogger<NotifyStudentsHandler> logger) { _logger = logger; } public Task HandleAsync(NotifyStudentsRequest request, CancellationToken cancellationToken) { _logger.Debug($\"Notifying students. JobType: {request.JobType}\"); return Task.CompletedTask; } } Note: Please look into BoltOn.Samples.Console to see the actual code. To know more about RecurringJob or BackgroundJob, please refer to Hangfire's documentation. Override ToString() method of the request object for a descriptive name to be displayed on the Hangfire Dashboard. BackgroundJob can be triggered anywhere within your application and need not be while bootstrapping.","title":"Hangfire"},{"location":"logging/","text":"Logging BoltOn uses .NET Core's logger internally, with just a custom adapter to mainly support unit testing, as .NET Core's ILogger has only one method and all the other methods are extension methods. You could use any logging provider as you wish, or you could inherit AppLogger<TType> and override the logging methods. Also, AppLoggerFactory can be used when AppLogger cannot be used. Serilog As IAppLogger is just an adapter to .NET Core's ILogger, Serilog or any other logging provider can be used in your applications. Check out Serilog's documentation to know more about sinks and how they can be configured in code/appSettings.","title":"Logging"},{"location":"logging/#logging","text":"BoltOn uses .NET Core's logger internally, with just a custom adapter to mainly support unit testing, as .NET Core's ILogger has only one method and all the other methods are extension methods. You could use any logging provider as you wish, or you could inherit AppLogger<TType> and override the logging methods. Also, AppLoggerFactory can be used when AppLogger cannot be used.","title":"Logging"},{"location":"logging/#serilog","text":"As IAppLogger is just an adapter to .NET Core's ILogger, Serilog or any other logging provider can be used in your applications. Check out Serilog's documentation to know more about sinks and how they can be configured in code/appSettings.","title":"Serilog"},{"location":"requestor/","text":"Requestor is the backbone of BoltOn. It follows the Request/Response and Command Message patterns. Since it doesn't depend on any particular framework like WebAPI, MVC etc., and comprises of pure C# classes, its handlers could be added to application/service layer and could be used in a simple WebAPI based application to all the way to message queuing (MassTransit) and background tasks (Hangfire) based applications. The main source of inspiration for the Requestor was Agatha , and various other projects like Brighter and MediatR . Request, Response and Handler In order to use the Requestor, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IRequest<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } To invoke the handler, you need to inject IRequestor in a class in your application, like a controller in WebAPI or a MVC application, and call ProcessAsync method. Check out the implemenation Requestor to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IRequestor _requestor; public StudentsController(IRequestor requestor) { this._requestor = requestor; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _requestor.ProcessAsync(new GetAllStudentsRequest()); return students; } } Note: Handlers get registered automatically while bootstrapping the application using services.BoltOn(); to disable the automatic handler registrations, DisableRequestorHandlerRegistrations() can be used. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(options => { options.DisableRequestorHandlerRegistrations(); }); Why Requestor? Adding a request, a handler and a response for every single request may look like as if we are writing a lot of code, but the advantages of it are: Every handler class will be responsible for one and only one thing, and thus follow Single Responsibility Principle , which makes them readable, maintainable, testable and reusable . The same request/handler and the requestor can be used in Web API based applications, background jobs using Hangfire and message queueing using AppServiceBus , and thus it will be easy for developers to pick it up.","title":"Requestor"},{"location":"requestor/#request-response-and-handler","text":"In order to use the Requestor, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IRequest<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } To invoke the handler, you need to inject IRequestor in a class in your application, like a controller in WebAPI or a MVC application, and call ProcessAsync method. Check out the implemenation Requestor to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IRequestor _requestor; public StudentsController(IRequestor requestor) { this._requestor = requestor; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _requestor.ProcessAsync(new GetAllStudentsRequest()); return students; } } Note: Handlers get registered automatically while bootstrapping the application using services.BoltOn(); to disable the automatic handler registrations, DisableRequestorHandlerRegistrations() can be used. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(options => { options.DisableRequestorHandlerRegistrations(); });","title":"Request, Response and Handler"},{"location":"requestor/#why-requestor","text":"Adding a request, a handler and a response for every single request may look like as if we are writing a lot of code, but the advantages of it are: Every handler class will be responsible for one and only one thing, and thus follow Single Responsibility Principle , which makes them readable, maintainable, testable and reusable . The same request/handler and the requestor can be used in Web API based applications, background jobs using Hangfire and message queueing using AppServiceBus , and thus it will be easy for developers to pick it up.","title":"Why Requestor?"},{"location":"samples/","text":"In order to run the Samples projects, SQL server should be configured. If you already have SQL server installed, please change the appsettings in the BoltOn.Samples.WebApi and BoltOn.Samples.Console projects. If you do not have them installed, you could use docker-compose , or run SQL Server separately in docker using the commands mentioned below and change the appsettings. Instead of using Redis, you could also configure in-memory cache. docker-compose Navigate to samples folder and execute any of the commands mentioned below. To build and run: docker-compose up -d --build To stop the conainers and remove the images: docker-compose down --rmi local Here is the docker-compose file used. It launches the samples API (http://localhost:5000/). You could test the StudentsController's actions using Postman or some other API testing tool. To run SQL Server separately: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 6000:1433 -d microsoft/mssql-server-linux:latest To run Redis separately: docker run -d -p 6379:6379 --name redis-local redis To run RabbitMq separately: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management OR To run all the above containers: docker-compose -f docker-compose-local.yml up -d","title":"Samples"},{"location":"samples/#docker-compose","text":"Navigate to samples folder and execute any of the commands mentioned below. To build and run: docker-compose up -d --build To stop the conainers and remove the images: docker-compose down --rmi local Here is the docker-compose file used. It launches the samples API (http://localhost:5000/). You could test the StudentsController's actions using Postman or some other API testing tool. To run SQL Server separately: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 6000:1433 -d microsoft/mssql-server-linux:latest To run Redis separately: docker run -d -p 6379:6379 --name redis-local redis To run RabbitMq separately: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management OR To run all the above containers: docker-compose -f docker-compose-local.yml up -d","title":"docker-compose"},{"location":"statemachine/","text":"Finite State Machine A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.[1] An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition. \u2013 Wikipedia To develop a workflow , we might end up wrting too many if/else and/or switch conditions, which might affect code readability and maintainability when there are too many states, events and transitions, which is where a State Machine will be quite useful. In order to use BoltOn's FiniteStateMachine , you have to do the following: Install BoltOn NuGet package. Declare states and events. Enums will be better (classes can be used too, but see to that you override Equals and GetHashCode methods). Like this: public enum MusicPlayerState { Stopped, Playing, Paused } public enum MusicPlayerEvent { Play, Stop, Pause, Previous, Next, Eject } Create a class encompassing the state machine with all the state transitions. Like this: public class MusicPlayerWorkflow { private FiniteStateMachine<MusicPlayerState, MusicPlayerEvent> _stateMachine; public MusicPlayerWorkflow() { _numberOfSongsInDvd = numberOfSongsInDvd; _stateMachine = new FiniteStateMachine<MusicPlayerState, MusicPlayerEvent>() _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused) .On(MusicPlayerEvent.Play) .Then(MusicPlayerState.Playing); } } Use the following methods to define the state transitions: In It is used to declare the state(s). More than one state could be declared. On It is used to declare the events that can be triggered in the In state(s). On can be combined with a boolean condition ( Func<bool> delegate) to enable transition only when the condition is satisfied; when the condition is satisfied, the current state gets set to the one defined in the Then state; and if not satisfied, the current state gets set to the one defined in the Else state. Like this: _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused) .On(MusicPlayerEvent.Play, () => IsDvdInserted()) .Then(MusicPlayerState.Playing) .Else(MusicPlayerState.Stopped); On also supports a parameter, which gets passed to the Func<bool> delegate. Like this: _stateMachine .In(MusicPlayerState.Playing) .On<int>(MusicPlayerEvent.Next, (currentSongIndex) => currentSongIndex + 1 <= 10) .Then(MusicPlayerState.Playing) .Else(MusicPlayerState.Stopped); Then It is used to declare the state that the current state should be set to when an event gets triggered. This should be declared even when Func<bool> is not declared in the On method. Then can be combined with an Action delegate, which gets triggered after the state transition. Like this: _stateMachine.In(MusicPlayerState.Playing) .On<int>(MusicPlayerEvent.Next, (currentSongIndex) => currentSongIndex + 1 <= 10) .Then(MusicPlayerState.Playing, () => { _stateMachine.Context[\"CurrentSongIndex\"] = (int)_stateMachine.Context[\"CurrentSongIndex\"] + 1; }) .Else(MusicPlayerState.Stopped); Else It is used to declare the state that the current state should be set to when an event gets triggered and the Func<bool> delegate in the On method returns false. Else can be combined with an Action delegate, which gets triggered after the state transition. Like this: _stateMachine.In(MusicPlayerState.Playing) .On<int>(MusicPlayerEvent.Next, (currentSongIndex) => currentSongIndex + 1 <= 10) .Then(MusicPlayerState.Playing, () => { _stateMachine.Context[\"CurrentSongIndex\"] = (int)_stateMachine.Context[\"CurrentSongIndex\"] + 1; }) .Else(MusicPlayerState.Stopped, () => { _stateMachine.Context[\"CurrentSongIndex\"] = 1; }) Trigger It is used to trigger events. It also supports a parameter, which gets passed to On and which inturn gets passed to the Func delegate. Like this: _stateMachine.Trigger(MusicPlayerEvent.Play); OR _stateMachine .In(MusicPlayerState.Playing) .On<(int, int)>(MusicPlayerEvent.Next, (c) => c.Item1 + 1 <= c.Item2) .Then(MusicPlayerState.Playing, () => currentSongIndex += 1) .Else(MusicPlayerState.Playing, () => currentSongIndex = 1); _stateMachine.Trigger(MusicPlayerEvent.Next, (inputCurrentSongIndex, numberOfSongsInDvd)); InitCurrentState If the current state is maintained in the class that encompasses the state machine or in database, it can be retrieved and initialized using this method before triggering the events. Initial state could also be initialized using the constructor of FiniteStateMachine . If the states are of type enum, the first enum will be initialized as the initial state. Like this: _stateMachine .InitCurrentState(MusicPlayerState.Paused) .Trigger(MusicPlayerEvent.Stop); OR new FiniteStateMachine<MusicPlayerState, MusicPlayerEvent>(MusicPlayerState.Playing); Note: FiniteStateMachine's Context property which is of type Dictionary<string, object> could be used to store temporary values. Anything that gets saved in the context stays as long as the FiniteStateMachine object is alive. FiniteStateMachine is stateful, and hence you must instantiate it or the encompassing class on every request. Sample Here is our sample music player workflow with all the states, events and transitions defined. public class MusicPlayerWorkflow { private FiniteStateMachine<MusicPlayerState, MusicPlayerEvent> _stateMachine; public MusicPlayerWorkflow(int numberOfSongsInDvd) { _numberOfSongsInDvd = numberOfSongsInDvd; _stateMachine = new FiniteStateMachine<MusicPlayerState, MusicPlayerEvent>() _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused) .On(MusicPlayerEvent.Play) .Then(MusicPlayerState.Playing); _stateMachine .In(MusicPlayerState.Playing, MusicPlayerState.Paused) .On(MusicPlayerEvent.Stop) .Then(MusicPlayerState.Stopped); _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused, MusicPlayerState.Playing) .On(MusicPlayerEvent.Eject) .Then(MusicPlayerState.Stopped); } public MusicPlayerState Play() { var nextState = _stateMachine.Trigger(MusicPlayerEvent.Play); return nextState; } public MusicPlayerState Stop() { var nextState = _stateMachine .InitCurrentState(MusicPlayerState.Playing) .Trigger(MusicPlayerEvent.Stop); return nextState; } } Here is the state diagram of our sample state machine:","title":"State Machine"},{"location":"statemachine/#finite-state-machine","text":"A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.[1] An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition. \u2013 Wikipedia To develop a workflow , we might end up wrting too many if/else and/or switch conditions, which might affect code readability and maintainability when there are too many states, events and transitions, which is where a State Machine will be quite useful. In order to use BoltOn's FiniteStateMachine , you have to do the following: Install BoltOn NuGet package. Declare states and events. Enums will be better (classes can be used too, but see to that you override Equals and GetHashCode methods). Like this: public enum MusicPlayerState { Stopped, Playing, Paused } public enum MusicPlayerEvent { Play, Stop, Pause, Previous, Next, Eject } Create a class encompassing the state machine with all the state transitions. Like this: public class MusicPlayerWorkflow { private FiniteStateMachine<MusicPlayerState, MusicPlayerEvent> _stateMachine; public MusicPlayerWorkflow() { _numberOfSongsInDvd = numberOfSongsInDvd; _stateMachine = new FiniteStateMachine<MusicPlayerState, MusicPlayerEvent>() _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused) .On(MusicPlayerEvent.Play) .Then(MusicPlayerState.Playing); } } Use the following methods to define the state transitions: In It is used to declare the state(s). More than one state could be declared. On It is used to declare the events that can be triggered in the In state(s). On can be combined with a boolean condition ( Func<bool> delegate) to enable transition only when the condition is satisfied; when the condition is satisfied, the current state gets set to the one defined in the Then state; and if not satisfied, the current state gets set to the one defined in the Else state. Like this: _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused) .On(MusicPlayerEvent.Play, () => IsDvdInserted()) .Then(MusicPlayerState.Playing) .Else(MusicPlayerState.Stopped); On also supports a parameter, which gets passed to the Func<bool> delegate. Like this: _stateMachine .In(MusicPlayerState.Playing) .On<int>(MusicPlayerEvent.Next, (currentSongIndex) => currentSongIndex + 1 <= 10) .Then(MusicPlayerState.Playing) .Else(MusicPlayerState.Stopped); Then It is used to declare the state that the current state should be set to when an event gets triggered. This should be declared even when Func<bool> is not declared in the On method. Then can be combined with an Action delegate, which gets triggered after the state transition. Like this: _stateMachine.In(MusicPlayerState.Playing) .On<int>(MusicPlayerEvent.Next, (currentSongIndex) => currentSongIndex + 1 <= 10) .Then(MusicPlayerState.Playing, () => { _stateMachine.Context[\"CurrentSongIndex\"] = (int)_stateMachine.Context[\"CurrentSongIndex\"] + 1; }) .Else(MusicPlayerState.Stopped); Else It is used to declare the state that the current state should be set to when an event gets triggered and the Func<bool> delegate in the On method returns false. Else can be combined with an Action delegate, which gets triggered after the state transition. Like this: _stateMachine.In(MusicPlayerState.Playing) .On<int>(MusicPlayerEvent.Next, (currentSongIndex) => currentSongIndex + 1 <= 10) .Then(MusicPlayerState.Playing, () => { _stateMachine.Context[\"CurrentSongIndex\"] = (int)_stateMachine.Context[\"CurrentSongIndex\"] + 1; }) .Else(MusicPlayerState.Stopped, () => { _stateMachine.Context[\"CurrentSongIndex\"] = 1; }) Trigger It is used to trigger events. It also supports a parameter, which gets passed to On and which inturn gets passed to the Func delegate. Like this: _stateMachine.Trigger(MusicPlayerEvent.Play); OR _stateMachine .In(MusicPlayerState.Playing) .On<(int, int)>(MusicPlayerEvent.Next, (c) => c.Item1 + 1 <= c.Item2) .Then(MusicPlayerState.Playing, () => currentSongIndex += 1) .Else(MusicPlayerState.Playing, () => currentSongIndex = 1); _stateMachine.Trigger(MusicPlayerEvent.Next, (inputCurrentSongIndex, numberOfSongsInDvd)); InitCurrentState If the current state is maintained in the class that encompasses the state machine or in database, it can be retrieved and initialized using this method before triggering the events. Initial state could also be initialized using the constructor of FiniteStateMachine . If the states are of type enum, the first enum will be initialized as the initial state. Like this: _stateMachine .InitCurrentState(MusicPlayerState.Paused) .Trigger(MusicPlayerEvent.Stop); OR new FiniteStateMachine<MusicPlayerState, MusicPlayerEvent>(MusicPlayerState.Playing); Note: FiniteStateMachine's Context property which is of type Dictionary<string, object> could be used to store temporary values. Anything that gets saved in the context stays as long as the FiniteStateMachine object is alive. FiniteStateMachine is stateful, and hence you must instantiate it or the encompassing class on every request.","title":"Finite State Machine"},{"location":"statemachine/#sample","text":"Here is our sample music player workflow with all the states, events and transitions defined. public class MusicPlayerWorkflow { private FiniteStateMachine<MusicPlayerState, MusicPlayerEvent> _stateMachine; public MusicPlayerWorkflow(int numberOfSongsInDvd) { _numberOfSongsInDvd = numberOfSongsInDvd; _stateMachine = new FiniteStateMachine<MusicPlayerState, MusicPlayerEvent>() _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused) .On(MusicPlayerEvent.Play) .Then(MusicPlayerState.Playing); _stateMachine .In(MusicPlayerState.Playing, MusicPlayerState.Paused) .On(MusicPlayerEvent.Stop) .Then(MusicPlayerState.Stopped); _stateMachine .In(MusicPlayerState.Stopped, MusicPlayerState.Paused, MusicPlayerState.Playing) .On(MusicPlayerEvent.Eject) .Then(MusicPlayerState.Stopped); } public MusicPlayerState Play() { var nextState = _stateMachine.Trigger(MusicPlayerEvent.Play); return nextState; } public MusicPlayerState Stop() { var nextState = _stateMachine .InitCurrentState(MusicPlayerState.Playing) .Trigger(MusicPlayerEvent.Stop); return nextState; } } Here is the state diagram of our sample state machine:","title":"Sample"},{"location":"utilities/","text":"IAppClock/AppClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IAppClock","title":"Utilities"},{"location":"utilities/#iappclockappclock","text":"There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IAppClock","title":"IAppClock/AppClock"},{"location":"web/","text":"BoltOn.Web has a few filters and middlewares to be used in MVC/WebAPI applications. In order to use the BoltOn.Web module, do the following: Install BoltOn.Web NuGet package. Call BoltOnWebModule() in your startup's BoltOn() method. Call TightenBolts() extenstion method for IApplicationBuilder . Filters ModelValidationFilter It's a global filter which validates the models and throws BadRequestException with the validation error messages set in the DataAnnotation attributes. CustomExceptionFilter It's a global filter to handle all the exceptions thrown in the application and returns JSON with the CorrelationId as the Id, error message and with any of these HTTP response codes: HTTP Response 400 - This is returned when a BadRequestException is thrown in the application, which usually happens for model validation errors. The ModelValidationFilter mentioned above throws this exception. HTTP Response 412 - This is returned when a BusinessValidationException is thrown in the application, which is mainly used to display the actual business validation message to the user. HTTP Response 500 - This status code is returned for all the unhandled exceptions with a generic error message or the actual exception message. The generic error message can be set in the appSettings with the key \"ErrorMessage\", and whether to return the actual exception message or a generic message can be controlled by a flag with the key \"IsShowErrors\" in the appSettings. It's recommended to enable IsShowErrors in the lower environments and disable it in the higher environments as the exception messages could have sensitive information. The global filters can be registered like this in a WebAPI application: services.AddControllers(c => { c.Filters.Add<CustomExceptionFilter>(); c.Filters.Add<ModelValidationFilter>(); }); For MVC application, AddControllersWithViews method can be used. Middlewares RequestLoggerContextMiddleware It's mainly used to add ClientIp, RequestUrl and CorrelationId to the LoggerContext, and it's automatically added when the BoltOn.Web is added.","title":"Web"},{"location":"web/#filters","text":"ModelValidationFilter It's a global filter which validates the models and throws BadRequestException with the validation error messages set in the DataAnnotation attributes. CustomExceptionFilter It's a global filter to handle all the exceptions thrown in the application and returns JSON with the CorrelationId as the Id, error message and with any of these HTTP response codes: HTTP Response 400 - This is returned when a BadRequestException is thrown in the application, which usually happens for model validation errors. The ModelValidationFilter mentioned above throws this exception. HTTP Response 412 - This is returned when a BusinessValidationException is thrown in the application, which is mainly used to display the actual business validation message to the user. HTTP Response 500 - This status code is returned for all the unhandled exceptions with a generic error message or the actual exception message. The generic error message can be set in the appSettings with the key \"ErrorMessage\", and whether to return the actual exception message or a generic message can be controlled by a flag with the key \"IsShowErrors\" in the appSettings. It's recommended to enable IsShowErrors in the lower environments and disable it in the higher environments as the exception messages could have sensitive information. The global filters can be registered like this in a WebAPI application: services.AddControllers(c => { c.Filters.Add<CustomExceptionFilter>(); c.Filters.Add<ModelValidationFilter>(); }); For MVC application, AddControllersWithViews method can be used.","title":"Filters"},{"location":"web/#middlewares","text":"RequestLoggerContextMiddleware It's mainly used to add ClientIp, RequestUrl and CorrelationId to the LoggerContext, and it's automatically added when the BoltOn.Web is added.","title":"Middlewares"}]}